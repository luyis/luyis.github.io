<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记录生活、记录美</title>
  <subtitle>如果我爱你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luyis.github.io/"/>
  <updated>2017-12-12T18:31:45.248Z</updated>
  <id>http://luyis.github.io/</id>
  
  <author>
    <name>Robynn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我对抽象的理解</title>
    <link href="http://luyis.github.io/2017/11/30/%E6%88%91%E5%AF%B9%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://luyis.github.io/2017/11/30/我对抽象的理解/</id>
    <published>2017-11-30T11:52:55.000Z</published>
    <updated>2017-12-12T18:31:45.248Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red" size="6"><strong>郑重声明：本文有误人子弟之嫌，概不负责！胡说八道正式开始～～～</strong></font><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>&emsp;&emsp;软件设计经常会被拿来和建筑设计去对比、但其实软件设计和它们的区别很大、那就是成型之后，需求是不停的变化、设计是需要响应这些变化的。你有听说过一座竣工的大厦，过一段时间要新加一个楼层就能往上加吗？不能！因为蓝图在设计之初就已经设计不变了，即不支持扩展性！所以软件设计后期随着需求的不停变化、复杂度逐步上升、往往新加一个小功能就影响全局！所以要求我们在软件设计之初就要考虑好后期的扩展性，而抽象无疑是必由之路。抽象本身并不能解决问题，通过抽象能简化和分解问题，使之更容易理解和控制，相应的解法也更具稳定性、普适性、重用性和可维护性。</p>
<h1 id="抽象的定义"><a href="#抽象的定义" class="headerlink" title="抽象的定义"></a><strong>抽象的定义</strong></h1><p>1、广义：抽象是人类认识和描绘世界最首要的工具！<br>2、狭义：抽象就是作减法和除法 </p>
<table>
<thead>
<tr>
<th>概念</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>减法：</td>
<td>去粗取精</td>
</tr>
<tr>
<td>除法：</td>
<td>异中求同、同类归并</td>
</tr>
<tr>
<td>结果：</td>
<td>大数变小数、复杂变简单</td>
</tr>
</tbody>
</table>
<h1 id="抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色"><a href="#抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色" class="headerlink" title="抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色"></a><strong>抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色</strong></h1><p>在软件工程中，系统开发生命周期最核心的有三个阶段：分析、设计、实现。对应对象导向式的方法：OOA、OOD、OOP</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>关注点</th>
<th>操作</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>OOA</td>
<td>概念模型</td>
<td>领域分析、应用分析、制定功能规范</td>
<td>以对象为中心</td>
</tr>
<tr>
<td>OOD</td>
<td>数学模型</td>
<td>制定实现规范</td>
<td>以接口为中心</td>
</tr>
<tr>
<td>OOP</td>
<td>数据结构</td>
<td>编码</td>
<td>以数据为中心</td>
</tr>
</tbody>
</table>
<hr>
<p>贯穿这3个阶段的主线正是抽象、并且抽象程度依次递减。</p>
<h1 id="抽象机制"><a href="#抽象机制" class="headerlink" title="抽象机制"></a><strong>抽象机制</strong></h1><p>常用两种抽象：参数抽象、规范抽象</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数抽象</td>
<td>形参</td>
</tr>
<tr>
<td>规范抽象</td>
<td>先验条件、后验条件<br>规范说明：功能与实现相分离的方法称为规范抽象</td>
</tr>
</tbody>
</table>
<h1 id="契约式设计与防御式编程"><a href="#契约式设计与防御式编程" class="headerlink" title="契约式设计与防御式编程"></a><strong>契约式设计与防御式编程</strong></h1><p>有了参数抽象和规范抽象并不能保证设计出一个良好的接口，所以出现了契约式设计<br>契约式设计的定义：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>性质</th>
<th>语言支持</th>
<th>特点</th>
<th>功效</th>
</tr>
</thead>
<tbody>
<tr>
<td>契约式设计</td>
<td>先君子后小人</td>
<td>异常机制和断言</td>
<td>职责清晰</td>
<td>保障程序的正确性</td>
</tr>
<tr>
<td>防御性编程</td>
<td>先小人后君子</td>
<td>任何语言都支持</td>
<td>职责不清晰</td>
<td>保障程序的健壮性</td>
</tr>
</tbody>
</table>
<p>两种方式相辅相成，保证软件系统的可靠性！</p>
<h1 id="五类基本抽象"><a href="#五类基本抽象" class="headerlink" title="五类基本抽象"></a><strong>五类基本抽象</strong></h1><table>
<thead>
<tr>
<th>抽象类型</th>
<th>能力</th>
<th>说明</th>
<th>抽象引入</th>
<th>抽象结果</th>
<th>抽象目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>过程抽象</td>
<td>赋予程序员自定义运算的能力</td>
<td>过程范式</td>
<td>运算</td>
<td>函数</td>
<td>将行为的逻辑属性与实现细节分离</td>
</tr>
<tr>
<td>数据抽象</td>
<td>赋予程序员自定义类型的能力</td>
<td>OOP的起源</td>
<td>类型</td>
<td>抽象数据类型</td>
<td>将数据的逻辑属性与表示细节分离</td>
</tr>
<tr>
<td>迭代抽象</td>
<td>赋予程序员自定义循环的能力</td>
<td>泛型范式的迭代器</td>
<td>循环</td>
<td>迭代器</td>
<td>将集合遍历与元素的获取细节分离</td>
</tr>
<tr>
<td>类型层级</td>
<td>赋予程序员自定义类族的能力</td>
<td>对象范式中的继承</td>
<td>类族</td>
<td>类型层级结构</td>
<td>将类型家族的公共行为与具体类型分离</td>
</tr>
<tr>
<td>多态抽象</td>
<td>赋予程序员自定义多态类型的能力</td>
<td>对象范式与泛型范式中的多态</td>
<td>多态类型</td>
<td>抽象类型（OOP）<br>参数类型（GP）</td>
<td>将类型的接口规范与实现代码分离<br>将类型与算法分离</td>
</tr>
</tbody>
</table>
<h1 id="数据抽象—OOP的核心和起源"><a href="#数据抽象—OOP的核心和起源" class="headerlink" title="数据抽象—OOP的核心和起源"></a><strong>数据抽象—OOP的核心和起源</strong></h1><p>&emsp;&emsp;首先我们介绍一个重要的概念，抽象数据类型（ADT）,如果一个数据类型依赖于具体实现，它就是具体（DTO），反之则是抽象（queue）。<font color="red">它关心的是抽象接口而不是具体实现。</font><br>&emsp;&emsp;现在举个例子来说明数据抽象，队列queue想必大家都比较清楚了，无论底层是用数组实现还是列表实现，其实用户根本不需关心，<font color="red">这便是队列的抽象所在</font>—用户不应知道 也不必知道它的具体实现,只能通过指定接口来进行‘暗箱操作’。这样经过数据抽象，队列的本质特征由API展现,非本质特征则屏蔽于客户的视野之外。</p>
<blockquote>
<blockquote>
<p><font color="red">结论</font>：参数抽象使得数据接口普适化，规范抽象使得数据接口契约化。一个完整的数据抽象除了对每个接口作规范说明外，还须对该数据类型作整体规范说明，OOP中的类注释文档即作此用。有了整体的规范描述，一个抽象数据类型才能真正在客户头脑中抽象化和概念化！</p>
</blockquote>
</blockquote>
<h1 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a><strong>封装、继承、多态</strong></h1><p>抽象（尤其数据抽象）是OOP的核心和起源，是封装、继承和多态的基础。下面从这三个方面来理解抽象<br>1、封装是什么？<br>&emsp;&emsp;将数据与行为包装在一起，这只是广义上的封装—打包！狭义上封装是在打包的基础上加上访问控制，以实现信息隐藏(掩盖实现细节)。</p>
<blockquote>
<blockquote>
<p>1、抽象意味着用户可以从高层的接口来看待或使用一类对象，而不用关心它底层的实现，而封装意味着用户不需要也无权访问底层的实现。”<br>  2、要记住信息隐藏是原则，封装只是一种实现方式</p>
</blockquote>
</blockquote>
<p>2、继承是什么？<br>&emsp;&emsp;子类继承父类或者子类遗传父类这两种说法其实都是不准确的，我所理解的继承是一种泛化关系。子类通过泛化得到父类，这是一种概念抽象的过程；父类通过特化得到子类。这是一种概念细化的过程；在设计过程中两种设计往往交替使用—–<strong>而这就是五种基本抽象之一类型层级</strong>。特别要注意：某些教科书上用衍生关系去描述继承关系是不对，这个真的是误人子弟，稍后带来例子<br>&emsp;&emsp;常见的继承有两种：类继承和接口继承。那继承的作用是什么?在回答这个问题之前，还要再问一个问题，面向对象编程中，最重要的思想是什么？是封装？是继承？是多态吗？都不对！应该是代码重用，严格来说应该是代码被重用。所以现在知道继承的作用是什么了吧？<br>&emsp;&emsp;类继承很好理解代码重用的观点，可以重用父类的代码，但是接口继承怎么重用？实现代码都没有啊！<br>&emsp;&emsp;抽象接口是控制反转的关键，通过抽象出一系列接口，并在这些接口上进行操作，使得控制逻辑不依赖于具体的实现；同时，具体的实现可以并不关心控制逻辑如何使用自己，它们会在需要的时候被调用。由此，使用对象的逻辑和对象本身充分解耦，由接口这座桥梁将二者联系起来。这样，代码得到了最大程度的被重用。是不是有点眼熟？没错，这就是面向接口编程的由来！</p>
<blockquote>
<blockquote>
<p><strong>实现继承消费可重用的旧代码，接口继承生产可重用的新代码</strong></p>
</blockquote>
</blockquote>
<p>谈到接口继承，不得不提 Liskov substitution principle（里氏变换原则），wikipedia 这样介绍它：</p>
<blockquote>
<blockquote>
<p>It states that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S.</p>
</blockquote>
</blockquote>
<p>这也是面向对象编程中常说的Substitutability（可替换性）。这段话翻译过来说就是，在类型系统中，如果类型S是类型T的子类型，那么类型T的任意对象可以被类型S的对象替换，且不影响程序的正确性。里氏变换是面向对象编程（其实适用于任何编程思想）非常重要的一个原则，也是程序得以多态的基石。如果我们做一个系统，要注意尽一切可能满足这一原则。</p>
<p>现在我们来举个经典例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bird</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;<span class="comment">//鸟会飞</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lay</span><span class="params">()</span></span>;<span class="comment">//鸟会下蛋</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">implements</span> <span class="title">Bird</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"企鹅不会飞"</span>)  </div><div class="line">  &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//企鹅会走路</span></div><div class="line">  &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lay</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//企鹅会下蛋</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//客户代码</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letGo</span><span class="params">(Bird bird)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (bird <span class="keyword">instanceof</span> Penguin)&#123;</div><div class="line">      ((Penguin)bird).walk(); </div><div class="line">    &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    bird.fly();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于企鹅是一种鸟，因此继承了Bird，为此不得不实现fly方法。但企鹅并不会飞，只好抛出UnsupportedOperationException的异常。其后果是客户代码不得不为这种特殊类型作特别处理，否则整个流程会被破坏。 类似地，如果还存在一个Ostrich类，由于鸵鸟不会飞只会跑，以上客户代码又得变成这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letGo</span><span class="params">(Bird bird)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (bird <span class="keyword">instanceof</span> Penguin)&#123;</div><div class="line">      ((Penguin)bird).walk(); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (bird <span class="keyword">instanceof</span> Ostrich)&#123;</div><div class="line">    ((Ostrich)bird).run();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    bird.fly();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这严重违反OCP原则,因为它对修改不是封闭的，以后代码为了兼容会越来越难看，这就是符合我们的生活逻辑但是不符合LSP设计的例子，所以用衍生关系去理解继承关系是有问题的，这就是一种蹩脚的设计！</p>
<blockquote>
<blockquote>
<p>接口继承是为了代码被重用，但是必须建立在LSP原则之上！</p>
</blockquote>
</blockquote>
<p>错就错在不应该把Penguin和Ostrich当作Bird的子类型，至于解决方案，大家可以想想～～</p>
<blockquote>
<blockquote>
<p>继承的主要作用：通过实现继承完成代码重用；通过接口继承完成代码被重用；建立概念的分类体系。</p>
</blockquote>
</blockquote>
<p>至于怎么合理使用继承，这里就不介绍了，内容太多，没准备～～～主要还是大家多多思考！</p>
<p>3、多态是什么？<br>多态是动静结合的产物，将静态类型的安全性和动态类型的灵活性融为一体。<br>静态类型语言中一般有两种实现方式： </p>
<blockquote>
<blockquote>
<p>一种利用GP（泛型编程）中的参数多态（parametric polymorphism）。<br>一种利用OOP中的包含多态（inclusion polymorphism）或称子类型多态（subtyping polymorphism）。</p>
</blockquote>
</blockquote>
<p>参数多态：让相同的实现代码应用于不同的场合<br>包含多态：让不同的实现代码应用于相同的场合<br>多态机制是保证代码的灵活性、可维护性和可重用性的终极武器。</p>
<p>举例子说明下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**一个可以验证用户名和密码的类*/</span> </div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Authenticator</span> </span>&#123;</div><div class="line"> <span class="comment">/**保存用户名和密码 */</span> </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span>  <span class="keyword">void</span> <span class="title">save</span><span class="params">( String user, String password)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</div><div class="line">      password = <span class="string">""</span>;</div><div class="line">  &#125; </div><div class="line">  store(user,encrypt(password)); </div><div class="line">  &#125; </div><div class="line">  <span class="comment">/**验证用户名和密码*/</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span>  <span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">( String user, String password)</span> </span>&#123; </div><div class="line">     String storedPassword = retrieve( user); </div><div class="line">     <span class="keyword">if</span> (storedPassword == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; </div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</div><div class="line">         password = <span class="string">""</span>; </div><div class="line">       &#125;</div><div class="line">     <span class="keyword">return</span> storedPassword. equals( encrypt( password)); </div><div class="line">   &#125; </div><div class="line">  <span class="comment">/** 保存用户名和加密过的密码 */</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">( String user, String encryptedPassword)</span></span>; </div><div class="line">  <span class="comment">/** 从用户名获取相应的加密过的密码 */</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">retrieve</span><span class="params">( String user)</span></span>; </div><div class="line">  <span class="comment">/**给明文单向加密，默认不加密 */</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">encrypt</span><span class="params">( String text)</span> </span>&#123; </div><div class="line">       <span class="keyword">return</span> text; </div><div class="line">      &#125; </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>我们可能会这样用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 一个简单的验证类，数据放在内存，密码保持明文 */</span></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAuthenticator</span> <span class="keyword">extends</span> <span class="title">Authenticator</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Map&lt; String, String&gt; usrPwd = <span class="keyword">new</span> HashMap&lt; String, String&gt;(); </div><div class="line"></div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">( String user, String encryptedPassword)</span> </span>&#123; </div><div class="line">      usrPwd.put( user, encryptedPassword); </div><div class="line">    &#125; </div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">retrieve</span><span class="params">( String user)</span> </span>&#123; </div><div class="line">      <span class="keyword">return</span> usrPwd.get( user); </div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这时候考虑到加密方式，我们可能会这样用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**一个安全的验证类，数据放在内存，密码经过SHA-1加密 */</span> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShalAuthenticator</span> <span class="keyword">extends</span> <span class="title">SimpleAuthenticator</span> </span>&#123; </div><div class="line"><span class="comment">// SHA-1算法 </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"SHA- 1"</span>; </div><div class="line"><span class="comment">// 避免依赖平台 </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF- 8"</span>; </div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">encrypt</span><span class="params">( String plainText)</span></span>&#123; </div><div class="line">   <span class="keyword">try</span> &#123; </div><div class="line">       MessageDigest md = MessageDigest.getInstance(ALGORITHM); </div><div class="line">       md.update(plainText.getBytes(CHARSET)); </div><div class="line">       <span class="keyword">byte</span> digest[] = md. digest(); </div><div class="line">       <span class="comment">//为简便起见用到了非标准的API,因此以下代码有警告 </span></div><div class="line">       <span class="keyword">return</span> (<span class="keyword">new</span> BASE64Encoder()).encode( digest);</div><div class="line">    &#125;<span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.getMessage()); </div><div class="line">      &#125; </div><div class="line">     <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; </div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.getMessage()); </div><div class="line">      &#125; </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAuthenticator</span> </span>&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args)</span> </span>&#123; </div><div class="line">     test( <span class="keyword">new</span> SimpleAuthenticator());</div><div class="line">     test( <span class="keyword">new</span> Sha1Authenticator()); </div><div class="line">    &#125; </div><div class="line">   </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">( Authenticator authenticator)</span> </span>&#123; </div><div class="line">     <span class="comment">//子类型多态：让不同的实现代码应用于相同的场合</span></div><div class="line">     test(authenticator, <span class="string">"user"</span>, <span class="string">"password"</span>); </div><div class="line">     test(authenticator, <span class="string">"user"</span>, <span class="string">"newPassword"</span>); </div><div class="line">     test(authenticator, <span class="string">"admin"</span>, <span class="string">"admin"</span>); </div><div class="line">     test(authenticator, <span class="string">"guest"</span>, <span class="keyword">null</span>); </div><div class="line">     test(authenticator, <span class="keyword">null</span>, <span class="string">"pass"</span>); </div><div class="line">     authenticator.save(<span class="string">"scott"</span>, <span class="string">"tiger"</span>); </div><div class="line">     <span class="comment">//大小写敏感 </span></div><div class="line">     <span class="keyword">assert</span>(!authenticator.authenticate(<span class="string">"scott"</span>, <span class="string">"TIGER"</span>)); </div><div class="line">     <span class="comment">//大小写敏感 </span></div><div class="line">     <span class="keyword">assert</span>(!authenticator.authenticate(<span class="string">"SCOTT"</span>, <span class="string">"tiger"</span>)); &#125; </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Authenticator authenticator, String user, String password)</span></span>&#123; </div><div class="line">     authenticator.save(user,password);</div><div class="line">     <span class="keyword">assert</span>(authenticator.authenticate(user, password)); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是模版方法：固定整体框架和流程以保证可重用性，留出一些子类定制点以保证可扩展性。<br>下面再给出一个更好的设计：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//键值对的存取接口 </span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">KeyValueKeeper</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">( String key, String value)</span></span>; </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">retrieve</span><span class="params">( String key)</span></span>; </div><div class="line">&#125;</div><div class="line"><span class="comment">//加密接口 </span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Encrypter</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">( String plainText)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authenticator</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> KeyValueKeeper keeper; </div><div class="line">  <span class="keyword">private</span> Encrypter encrypter; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Authenticator</span><span class="params">( KeyValueKeeper keeper, Encrypter encrypter)</span> </span>&#123; </div><div class="line">    <span class="keyword">this</span>.keeper = keeper; </div><div class="line">    <span class="keyword">this</span>.encrypter = encrypter; </div><div class="line">  &#125; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">( String user, String password)</span> </span>&#123; </div><div class="line">    <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</div><div class="line">       password = <span class="string">""</span>; </div><div class="line">    &#125;  </div><div class="line">     keeper.store(user, encrypter. encrypt( password));</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">( String user, String password)</span> </span>&#123; </div><div class="line">     String storedPassword = keeper. retrieve( user); </div><div class="line">     <span class="keyword">if</span> (storedPassword == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; </div><div class="line">     <span class="keyword">if</span> (password == <span class="keyword">null</span>) password = <span class="string">""</span>; </div><div class="line">     <span class="keyword">return</span> storedPassword. equals( encrypter.encrypt( password)); </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryKeeper</span> <span class="keyword">implements</span> <span class="title">KeyValueKeeper</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> Map&lt; String, String&gt; keyValue = <span class="keyword">new</span> HashMap&lt; String, String&gt;(); </div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">( String key, String value)</span> </span>&#123; </div><div class="line">    keyValue. put( key, value); </div><div class="line">  &#125; </div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">retrieve</span><span class="params">( String key)</span> </span>&#123; </div><div class="line">    <span class="keyword">return</span> keyValue. get( key); </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainEncrypter</span> <span class="keyword">implements</span> <span class="title">Encrypter</span> </span>&#123; </div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">( String plainText)</span> </span>&#123; </div><div class="line">    <span class="keyword">return</span> plainText;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sha1Encrypter</span> <span class="keyword">implements</span> <span class="title">Encrypter</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"SHA- 1"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF- 8"</span>;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">( String plainText)</span> </span>&#123; </div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      MessageDigest md = MessageDigest.getInstance(ALGORITHM);</div><div class="line">      md.update( plainText.getBytes(CHARSET)); </div><div class="line">      <span class="keyword">byte</span> digest[] = md.digest();</div><div class="line">      <span class="keyword">return</span>(<span class="keyword">new</span> BASE64Encoder()).encode(digest); </div><div class="line">      &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123; </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.getMessage()); </div><div class="line">      &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.getMessage()); </div><div class="line">      &#125; </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAuthenticator</span> </span>&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args)</span> </span>&#123;</div><div class="line">   test( <span class="keyword">new</span> Authenticator( <span class="keyword">new</span> MemoryKeeper(), <span class="keyword">new</span> PlainEncrypter())); </div><div class="line">   test( <span class="keyword">new</span> Authenticator( <span class="keyword">new</span> MemoryKeeper(), <span class="keyword">new</span> Sha1Encrypter())); </div><div class="line">   &#125; </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">( Authenticator authenticator)</span> </span>&#123;</div><div class="line">    <span class="comment">//同上</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是策略模式。</p>
<h1 id="万人迷的类"><a href="#万人迷的类" class="headerlink" title="万人迷的类"></a><strong>万人迷的类</strong></h1><p>一个万人迷的类一定充分体现ADT思想的类：有优雅的外形—抽象，有丰富的内涵—数据，有鲜明的个性—类型<br><img src="/images/ADT.jpeg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&emsp;&emsp;抽象能力不止是程序员应该去关注的，其他的行业人员也应该去关注的，因为它能帮助我们简化问题、解决问题<br>但是说了这么多，至于怎么提升却还是显得那么“抽象”，借用下Bob大叔的话：“阅读代码—&gt;而且是阅读大量的优秀代码”，不停的实践。<br>我们程序员平常的工作大抵就是理解业务需求，开始设计，编码实现，维护等，能设计出一个符合参数抽象和规范抽象的接口就是一个难得的程序员了！<br>其实技术和业务哪个重要？我觉得就像语言之争，并没有什么大的意义，我觉得是相辅相成的，业务理解力强有助于技术实现，而技术强能更快的、更好的实现业务需求<br>以上几点纯属胡说八道、不要当真、因为每个人对抽象的理解有角度之分和程度之别</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;red&quot; size=&quot;6&quot;&gt;&lt;strong&gt;郑重声明：本文有误人子弟之嫌，概不负责！胡说八道正式开始～～～&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
      <category term="胡说八道系列" scheme="http://luyis.github.io/categories/%E8%83%A1%E8%AF%B4%E5%85%AB%E9%81%93%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="小议抽象" scheme="http://luyis.github.io/tags/%E5%B0%8F%E8%AE%AE%E6%8A%BD%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>The introduction of MongoDB</title>
    <link href="http://luyis.github.io/2017/09/15/The-introduction-of-MongoDB/"/>
    <id>http://luyis.github.io/2017/09/15/The-introduction-of-MongoDB/</id>
    <published>2017-09-15T13:23:04.000Z</published>
    <updated>2017-10-12T10:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/mongoDB.png" alt=""><br> <a id="more"></a><br>    感谢在生命的最好的年华中，遇见了你—网易云音乐</p>
 <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=439915614&auto=0&height=66"></iframe>

<h1 id="MongoDB的发展"><a href="#MongoDB的发展" class="headerlink" title="MongoDB的发展"></a><strong>MongoDB的发展</strong></h1><p>2007年10月，MongoDB由10gen团队所发展。2009年2月首度推出、现在稳定版是3.4. <font color="red">现在社区非常繁荣</font></p>
<p>MongoDB是什么?<br>   1、MongoDB is an open-source document database that provides high performance, high availability, and automatic scaling.<br>   2、MongoDB 是由C++语言编写的,支持多种编程语言<br>   3、MongoDB 是一个面向集合的,模式自由的文档型数据库<br>   4、它在许多场景下可用于替代传统的关系型数据库或键/值存储方式</p>
<p>   主要特征：<br>      1、高性能 （数据模型有关、减少与数据库系统的I/O交互次数、内嵌和引用）<br>      2、丰富的查询语言 （CRUD、Data Aggregation、文件检索、地理空间查询）<br>      3、高可用性 （自动故障恢复、数据冗余）<br>      4、水平扩展能力 （分片）<br>      5、高性能 （多个存储引擎的支持 默认是WiredTiger）</p>
<p>   文档结构:<br>   MongoDB中的一条记录就是一个文档，是一个数据结构，由字段和值对组成。MongoDB文档与JSON对象类似。字段的值有可能包括其它文档、数组以及文档数组</p>
<p><img src="https://docs.mongodb.com/manual/_images/crud-annotated-document.bakedsvg.svg" alt=""></p>
<h1 id="BSON"><a href="#BSON" class="headerlink" title="BSON"></a><strong>BSON</strong></h1><p>在MongoDB中，文档是对数据的抽象，由于 MongoDB 支持嵌入文档、数组和哈希等多种复杂数据结构的使用，所以它最终将所有的数据以<font color="red"><strong>BSON</strong></font> 的数据格式存储起来<br>BSON是一个轻量级的二进制数据格式。MongoDB能够使用BSON，并将BSON作为数据存储存放在磁盘中。</p>
<font color="red"><strong>使用BSON格式出于以下3种目的：</strong></font>

<table>
<thead>
<tr>
<th>BSON特征</th>
<th>优势</th>
</tr>
</thead>
<tbody>
<tr>
<td><font color="red">效率</font></td>
<td>BSON是为效率而设计的，它只需要使用很少的空间。即使在最坏的情况下，BSON格式也比JSON格式在最好的情况下存储效率高。</td>
</tr>
<tr>
<td><font color="red">传输性</font></td>
<td>在某些情况下，BSON会牺牲额外的空间让数据的传输更加方便。比如，字符串的传输的前缀会标识字符串的长度，而不是在字符串的末尾打上结束的标记。这样的传输形式有利于MongoDB修改传输的数据。</td>
</tr>
<tr>
<td><font color="red">性能</font></td>
<td>最后，BSON格式的编码和解码都是非常快速的。它使用了C风格的数据表现形式，这样在各种语言中都可以高效地使用。</td>
</tr>
</tbody>
</table>
<p>更多关于BSON的介绍，可以参考：<a href="http://www.bsonspec.org" target="_blank" rel="external">http://www.bsonspec.org</a></p>
<h1 id="MongoDB架构"><a href="#MongoDB架构" class="headerlink" title="MongoDB架构"></a><strong>MongoDB架构</strong></h1><p>现有流行的数据库其实都有着非常相似的架构，MongoDB 其实就与 MySQL 中的架构相差不多，底层都使用了<font color="red">可插拔</font>的存储引擎以满足用户的不同需要<br><img src="/images/mongoDB架构.jpeg" alt=""><br>用户可以根据表中的数据特征选择不同的存储引擎，它们可以在同一个 MongoDB 的实例中使用；在最新版本的 MongoDB 中使用了 WiredTiger 作为默认的存储引擎，WiredTiger 提供了不同粒度的并发控制和压缩机制，能够为不同种类的应用提供了最好的性能和存储效率</p>
<h1 id="概念映射关系"><a href="#概念映射关系" class="headerlink" title="概念映射关系"></a><strong>概念映射关系</strong></h1><p><img src="/images/对比结构图.jpeg" alt=""></p>
<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a><strong>数据模型</strong></h1><p>1、存储在MongoDB中的数据有着非常灵活的Schema。我们不需要在插入数据之前就要定义好表中的数据结构，而且MongoDB不对Collection的数据结构进行任何限制，但是在实际使用中，同一个Collection中的大多数文档都具有类似的结构。<br><img src="/images/document.jpeg" alt=""><br>2、由于文档具有复杂的结构，所以在为MongoDB应用设计数据模型时，如何表示数据模型之间的关系其实是需要开发者需要仔细考虑的，这样才能利用MongoDB提供的诸多特性提升查询的效率，MongoDB 为表示文档之间的关系提供了两种不同的方法：<font color="red">引用和嵌入</font></p>
<p>引用(Reference):<br><img src="/images/引用.jpeg" alt=""><br>标准化的数据模型，类似mysql的外键，但是由于mongoDB不支持join，所以增加了客户端和MongoDB 之间的交互次数（Round-Trip）也会导致查询变慢，甚至非常严重的性能问题</p>
<p>嵌入(Embedded):<br><img src="/images/嵌入.jpeg" alt=""><br>不标准的数据模型,子文档是父文档的一个值<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  _id: &lt;ObjectId1&gt;,</div><div class="line">  username: "changfen",</div><div class="line">  age: 18,</div><div class="line">  contact: [</div><div class="line">    &#123;</div><div class="line">      _id: &lt;ObjectId2&gt;,</div><div class="line">      email: "changfen@2dfire.cn"</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>适用于包含关系的数据关系，例如用户与联系方式</p>
<h1 id="主键和索引"><a href="#主键和索引" class="headerlink" title="主键和索引"></a><strong>主键和索引</strong></h1><p>默认索引（主键）<br>MongoDB中所有的文档也都有一个唯一的 _id字段，在默认情况下所有的文档都使用一个长12字节的 ObjectId 作为默认索引：<br><img src="/images/objectId.jpeg" alt=""><br>前四位代表当前 _id 生成时的 Unix 时间戳，在这之后是三位的机器标识符和两位的处理器标识符，最后是一个三位的计数器，初始值就是一个随机数；通过这种方式代替递增的 id 能够解决分布式的 MongoDB 生成唯一标识符的问题，同时可以在一定程度上保证 id 的的增长是递增的。</p>
<p>mongoDB的索引与mysql的索引差不多，无论是底层的数据结构还是索引类型都几乎完全相同，只是mongoDB支持更多的索引种类<br><img src="/images/索引种类.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th>索引类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>单字段索引</td>
<td>db.users.createIndex( { age: -1 } )<br>db.users.createIndex( { age: 1 } )</td>
</tr>
<tr>
<td>复合索引</td>
<td>db.users.createIndex( { username: 1, age: -1 } )<br>db.users.createIndex( { username: 1, age: 1 } )</td>
</tr>
<tr>
<td>多键索引</td>
<td>db.collection.createIndex( { address: 1 } )<br>多键索引与单键索引创建形式相同，区别在于字段的值<br>单键索引：值为一个单一的值，例如字符串，数字或者日期，<br>多键索引：值具有多个记录，例如数组</td>
</tr>
<tr>
<td>文本索引</td>
<td>业务上更推荐Elasticsearch这种专业的搜索</td>
</tr>
<tr>
<td>地理位置索引</td>
<td>附近的店铺等</td>
</tr>
<tr>
<td>其他索引</td>
<td>有兴趣可以研究下</td>
</tr>
</tbody>
</table>
<h1 id="API例子"><a href="#API例子" class="headerlink" title="API例子"></a><strong>API例子</strong></h1><table>
<thead>
<tr>
<th>操作</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>db.inventory.insertOne(<br>{ item: “canvas”, qty: 100, tags: [“cotton”], size: { h: 28, w: 35.5, uom: “cm” } }<br>)</td>
<td>插入单条记录</td>
</tr>
<tr>
<td>插入多条</td>
<td>db.inventory.insertMany([<br>{ item: “journal”, qty: 25, size: { h: 14, w: 21, uom: “cm” }, status: “A” },<br>{ item: “notebook”, qty: 50, size: { h: 8.5, w: 11, uom: “in” }, status: “A” },<br>{ item: “paper”, qty: 100, size: { h: 8.5, w: 11, uom: “in” }, status: “D” },<br>{ item: “planner”, qty: 75, size: { h: 22.85, w: 30, uom: “cm” }, status: “D” },<br>{ item: “postcard”, qty: 45, size: { h: 10, w: 15.25, uom: “cm” }, status: “A” }<br>])</td>
<td>插入多条记录</td>
</tr>
<tr>
<td>查询</td>
<td>db.inventory.find( { item: “canvas” } )<br>db.inventory.find( { status: { $in: [ “A”, “D” ] } } )<br>db.inventory.find( { status: “A”, qty: { $lt: 30 } } )<br>db.inventory.find( { $or: [ { status: “A” }, { qty: { $lt: 30 } } ] } )</td>
<td>查询<br>SELECT <em> FROM inventory WHERE item = “canvas”<br>SELECT </em> FROM inventory WHERE status in (“A”, “D”)<br>SELECT <em> FROM inventory WHERE status = “A” AND qty &lt; 30<br>SELECT </em> FROM inventory WHERE status = “A” OR qty &lt; 30</td>
</tr>
</tbody>
</table>
<p>以上只是一些简单的例子，mongoDB语法非常丰富，而且提供了几乎世面上所有流行的编程语言的API</p>
<h1 id="Morphia"><a href="#Morphia" class="headerlink" title="Morphia"></a><strong>Morphia</strong></h1><p>由于mongoDB语法不太友好（特别对于我们java开发者），所以推荐Morphia这个官方版的ODM工具</p>
<h1 id="MongoDB应用场景"><a href="#MongoDB应用场景" class="headerlink" title="MongoDB应用场景"></a><strong>MongoDB应用场景</strong></h1><p>1、游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新<br>2、物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。<br>3、社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能<br>4、物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析<br>5、视频直播，使用 MongoDB 存储用户信息、礼物信息等<br>6、······等等<br><img src="/images/应用场景.dms" alt=""></p>
<h1 id="MongoDB的优点与缺点"><a href="#MongoDB的优点与缺点" class="headerlink" title="MongoDB的优点与缺点"></a><strong>MongoDB的优点与缺点</strong></h1><table>
<thead>
<tr>
<th>MongoDB特性</th>
<th>优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>事务支持</td>
<td>MongoDB目前只支持单文档事务，需要复杂事务支持的场景暂时不适合</td>
</tr>
<tr>
<td>灵活的文档模型</td>
<td>JSON格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代</td>
</tr>
<tr>
<td>高可用复制集</td>
<td>满足数据高可靠、服务高可用的需求，运维简单，故障自动切换</td>
</tr>
<tr>
<td>可扩展分片集群</td>
<td>海量数据存储，服务能力水平扩展</td>
</tr>
<tr>
<td>高性能</td>
<td>mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足各种场景需求</td>
</tr>
<tr>
<td>强大的索引支持</td>
<td>地理位置索引可用于构建各种O2O 应用、文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求</td>
</tr>
<tr>
<td>Gridfs</td>
<td>解决文件存储的需求</td>
</tr>
<tr>
<td>aggregation &amp; mapreduce</td>
<td>解决数据分析场景需求，用户可以自己写查询语句或脚本，将请求都分发到 MongoDB 上完成</td>
</tr>
</tbody>
</table>
<p>1、厂商的噱头，并不是说NoSQL一定比关系型数据库好，因为数据库的性能不止与数据库本身的设计有关系，还与开发者对表结构和索引的设计、存储引擎的选择和业务有着巨大的关系!<br>2、MongoDB布道者TJ博士设计了几个选择题来辅助我们是否应该使用MongoDB</p>
<table>
<thead>
<tr>
<th>应用特征</th>
<th>YES / NO</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用不需要事务及复杂join支持</td>
<td>Yes</td>
</tr>
<tr>
<td>新应用，需求会变，数据模型无法确定，想快速迭代开发</td>
<td>？</td>
</tr>
<tr>
<td>应用需要2000-3000以上的读写QPS（更高也可以）</td>
<td>？</td>
</tr>
<tr>
<td>应用需要TB甚至 PB 级别数据存储</td>
<td>?</td>
</tr>
<tr>
<td>应用发展迅速，需要能快速水平扩展</td>
<td>?</td>
</tr>
<tr>
<td>应用要求存储的数据不丢失</td>
<td>?</td>
</tr>
<tr>
<td>应用需要99.999%高可用</td>
<td>?</td>
</tr>
<tr>
<td>应用需要大量的地理位置查询、文本查询</td>
<td>？</td>
</tr>
</tbody>
</table>
<p>如果上述有1个 Yes，可以考虑 MongoDB，2个及以上的 Yes，选择 MongoDB 绝不会后悔</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a><strong>扩展阅读</strong></h1><p>1、WiredTiger存储引擎实现<br>2、MongoDB 复制集原理实现</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><p><a href="https://docs.mongodb.com/manual/?_ga=2.190019746.885390148.1505483057-1629220430.1505483057" target="_blank" rel="external">MongoDB官方文档</a><br><a href="https://www.mongodb.com/zh/mongodb-architecture" target="_blank" rel="external">MongoDB架构指南</a></p>
<h1 id="干货"><a href="#干货" class="headerlink" title="干货"></a><strong>干货</strong></h1><p><img src="/images/波多老师.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;img src=&quot;/images/mongoDB.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://luyis.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="NoSQL" scheme="http://luyis.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>致橡树</title>
    <link href="http://luyis.github.io/2017/08/10/%E8%87%B4%E6%A9%A1%E6%A0%91/"/>
    <id>http://luyis.github.io/2017/08/10/致橡树/</id>
    <published>2017-08-10T15:43:29.000Z</published>
    <updated>2017-09-16T16:02:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得这首诗挺美的，就贴过来了！</p>
<a id="more"></a>
<p><img src="/images/小红.jpeg" alt="致橡树"></p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=489998494&auto=1&height=66"></iframe><br>致橡树<br>我如果爱你——<br>　　绝不像攀援的凌霄花，<br>　　借你的高枝炫耀自己；<br>　　我如果爱你——<br>　　绝不学痴情的鸟儿，<br>　　为绿荫重复单调的歌曲；<br>　　也不止像泉源，<br>　　常年送来清凉的慰藉；<br>　　也不止像险峰，<br>　　增加你的高度，衬托你的威仪。<br>　　甚至日光，<br>　　甚至春雨。<br>    不，这些都还不够！<br>　　我必须是你近旁的一株木棉，<br>　　作为树的形象和你站在一起。<br>　　根，紧握在地下；<br>　　叶，相触在云里。<br>　　每一阵风过，<br>　　我们都互相致意，<br>　　但没有人，<br>　　听懂我们的言语。<br>　　你有你的铜枝铁干，<br>　　像刀，像剑，也像戟；<br>　　我有我红硕的花朵，<br>　　像沉重的叹息，<br>　　又像英勇的火炬。<br>   我们分担寒潮、风雷、霹雳；<br>　　我们共享雾霭、流岚、虹霓。<br>　　仿佛永远分离，<br>　　却又终身相依。<br>　　这才是伟大的爱情，<br>　　坚贞就在这里：<br>　　爱——<br>　　不仅爱你伟岸的身躯，<br>　　也爱你坚持的位置，<br>　　足下的土地。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我觉得这首诗挺美的，就贴过来了！&lt;/p&gt;
    
    </summary>
    
      <category term="诗词歌赋" scheme="http://luyis.github.io/categories/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"/>
    
    
      <category term="花前月下" scheme="http://luyis.github.io/tags/%E8%8A%B1%E5%89%8D%E6%9C%88%E4%B8%8B/"/>
    
  </entry>
  
  <entry>
    <title>奇怪！为什么一个线程能访问到一个没有被初始化的对象？</title>
    <link href="http://luyis.github.io/2017/08/10/%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%BA%86%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>http://luyis.github.io/2017/08/10/当一个线程访问了一个没有初始化的对象/</id>
    <published>2017-08-09T16:16:10.000Z</published>
    <updated>2017-09-16T12:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>   难道你就不奇怪，没有被初始化的对象是怎么出现的吗？😳<br><a id="more"></a><br>   如果一个对象的初始化操作非常昂贵，这时候可以考虑<font color="red"><strong>Lazy Initialization</strong></font>。<br>   比如获取数据库连接资源、APP启动速度过慢等。<br>   但是要实现线程安全的Lazy Initialization需要一些技巧。<br>）</p>
<p>我们先来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitializationDemo</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">//1：A线程执行</span></div><div class="line">           instance = <span class="keyword">new</span> Instance(); <span class="comment">//2：B线程执行</span></div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假如静态方法getInstance()被两个线程A和B访问、当A执行到1的时候可能条件语句是false的，直接返回了还未被初始化instance，后续用这个instance处理一些逻辑就会出现不可预知的问题了。</p>
<p>问题大概知道了，那有什么办法解决呢？<br>1、synchronized同步：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeLazyInitializationDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</div><div class="line">            instance = <span class="keyword">new</span> Instance();</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<font color="green">synchronized将导致性能开销。如果getInstance()被多个线程频繁的调用，将会导致程序执行性能的下降</font>

</blockquote>
<p>2、进阶方案：double-checked locking<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLockingDemo</span> </span>&#123;                  <span class="comment">//1</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;                    <span class="comment">//2</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;               <span class="comment">//3</span></div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                          <span class="comment">//4:第一次检查</span></div><div class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLocking.class) &#123;  <span class="comment">//5:加锁</span></div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)                    <span class="comment">//6:第二次检查</span></div><div class="line">                    instance = <span class="keyword">new</span> Instance();           <span class="comment">//7:问题的根源出在这里</span></div><div class="line">            &#125;                                            <span class="comment">//8</span></div><div class="line">        &#125;                                                <span class="comment">//9</span></div><div class="line">        <span class="keyword">return</span> instance;                                 <span class="comment">//10</span></div><div class="line">    &#125;                                                    <span class="comment">//11</span></div><div class="line">&#125;                                                        <span class="comment">//12</span></div></pre></td></tr></table></figure></p>
<p>但是在执行到4的时候，和UnsafeLazyInitializationDemo有同样的问题。</p>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>为什么会产生这样的现象呢？那是因为JVM对new操作的处理过程如下：</p>
<font color="red">1、memory = allocate();     //1：分配对象的内存空间<br>2、ctorInstance(memory);    //2：初始化对象<br>3、instance = memory;       //3：设置instance指向刚分配的内存地址</font>

<p>其中2和3可以指令重排序、单线程指令重排序可以提高性能</p>
<blockquote>
<p><font color="red"><em>The Java Language Specification, Java SE 7 Edition</em></font> 的intra-thread semantics规则保证重排序不会改变单线程内的程序执行结果</p>
</blockquote>
<p>但是多线程就不能保证了！</p>
<p>问题根源：<br>1、不允许2和3重排序；<br>2、允许2和3重排序，但不允许其他线程“看到”这个重排序。<br>我们可以想出两个办法来实现线程安全的延迟初始化：</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="基于volatile的double-checked-locking的解决方案"><a href="#基于volatile的double-checked-locking的解决方案" class="headerlink" title="基于volatile的double-checked locking的解决方案"></a>基于volatile的double-checked locking的解决方案</h2><p>原理：不允许2和3重排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLockingDemo</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</div><div class="line">                    instance = <span class="keyword">new</span> Instance();<span class="comment">//instance为volatile，现在没问题了</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h2><p>原理：允许2和3重排序，但不允许其他线程“看到”这个重排序</p>
<blockquote>
<p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。<br>有兴趣可以看看JVM的类加载过程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> InstanceHolder.instance ;  <span class="comment">//这里将导致InstanceHolder类被初始化</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化一个类，包括执行这个类的静态初始化和初始化在这个类中声明的静态字段。根据java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：</p>
<blockquote>
<p>1、T是一个类，而且一个T类型的实例被创建；<br>2、T是一个类，且T中声明的一个静态方法被调用；<br>3、T中声明的一个静态字段被赋值；<br>4、T中声明的一个静态字段被使用，而且这个字段不是一个常量字段；<br>5、T是一个顶级类（top level class，见java语言规范的§7.6），而且一个断言语句嵌套在T内部被执行。</p>
</blockquote>
<p>在ClassLoaderDemo示例代码中，首次执行getInstance()的线程将导致InstanceHolder类被初始化（符合情况4）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案</p>
<blockquote>
<font color="red">Effective Java 建议慎用Lazy Initialization</font>

</blockquote>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>1、单例模式<br>2、JVM类加载<br>3、synchronized关键字<br>4、volatile关键字</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h1&gt;&lt;p&gt;   难道你就不奇怪，没有被初始化的对象是怎么出现的吗？😳&lt;br&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://luyis.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Effective Java" scheme="http://luyis.github.io/tags/Effective-Java/"/>
    
      <category term="面向模式的软件体系架构卷三中Lazy Acquisition模式" scheme="http://luyis.github.io/tags/%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%E5%8D%B7%E4%B8%89%E4%B8%ADLazy-Acquisition%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
