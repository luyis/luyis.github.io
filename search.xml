<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[我对抽象的理解]]></title>
      <url>/2017/11/30/%E6%88%91%E5%AF%B9%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a><strong>序言</strong></h1><p>本文不追求系统和全面，也做不到如此，只是力求从不同的选点、角度和深度去展示个人的一点理解<br>软件设计经常会被拿来和建筑设计去对比、但其实软件设计和它们的区别很大、那就是成型之后，需求是不停的变化、设计是需要响应这些变化的。你有听说过一座竣工的大厦，过一段时间要新加一个楼层就能往上加吗？不能！因为蓝图在设计之初就已经设计不变了，即不支持扩展性！所以软件设计后期随着需求的不停变化、复杂度逐步上升、往往新加一个小功能就影响全局！所以要求我们在软件设计之初就要考虑好后期的扩展性，而抽象无疑是必由之路。抽象本身并不能解决问题，通过抽象能简化和分解问题，使之更容易理解和控制，相应的解法也更具稳定性、普适性、重用性和可维护性。</p>
<h1 id="程序员的能力"><a href="#程序员的能力" class="headerlink" title="程序员的能力"></a><strong>程序员的能力</strong></h1><p>如果有人问程序员最重要的能力是什么？学习能力、逻辑思维能力、解决问题能力、沟通能力等等～～～<br>其实TMD都很重要！所以coder是苦逼的！但是在软件设计领域、抽象思维能力还是蛮重要的！</p>
<h1 id="抽象的定义"><a href="#抽象的定义" class="headerlink" title="抽象的定义"></a><strong>抽象的定义</strong></h1><p>   1、广义：抽象是人类认识和描绘世界最首要的工具！<br>   2、狭义：抽象就是作减法和除法<br>           减法：去粗取精<br>           除法：异中求同、同类归并<br>           结果：大数变小数、复杂变简单<br>2、语法和语义的区别、抽象是语义上的概念<br>3、抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色<br>   在软件工程中，系统开发生命周期最核心的有三个阶段：分析、设计、实现。<br>   对应对象导向式的方法：OOA、OOD、OOP<br>   概念模型、数学模型、数据结构<br>   分析阶段前期：领域分析—领域模型是对系统所涉及的对应于现实世界的某些特定领域的抽象，是软件系统的核心和基石<br>   分析阶段后起：应用分析<br>   贯穿这3个阶段的主线正是抽象、并且抽象程度依次递减。<br>   实现阶段：常用两种抽象 参数抽象、规范抽象<br>   先验条件、后验条件、接口设计、规范说明 ：功能与实现相分离的方法称为规范抽象<br>   契约式设计：异常机制和断言<br>   防御性编程<br>   借助这两种抽象机制，我们可以实现五类基本抽象：<br>   1、过程抽象（ procedural abstraction）赋予程序员自定义运算（ operation）的能力<br>   2、数据抽象（ data abstraction）赋予程序员自定义类型（ type）的能力<br>   3、迭代抽象（ iteration abstraction） 赋予程序员自定义循环（ loop）的能力<br>   4、类型层级（ type hierarchy）赋予程序员自定义类族（ type family）的能力<br>   5、多态抽象（ polymorphic abstraction） 赋予程序员自定义多态类型（ polymorphic type）的能力。<br>    这中间， 过程抽象是过程范式的关键，大家已经非常熟悉了。 迭代抽象也不陌生， 我们在讨论泛型 范式时提到的迭代器（ iterator）便是迭代抽象的结果。 类型层级涉及对象范式中的继承，多态 抽象涉及对象范式与泛型范式中的多态，下面主要谈谈数据抽象，它是OOP的起源。</p>
<p>4、从Java的封装、继承、多态又是如何理解抽象的<br>5、抽象和接口放在一起对比真的合适吗？面向对象编程和面向接口编程的区别，代码复用！<br>接口的定义 广义上的定义和狭义上的区别<br>6、对象系统和面向对象系统的区别<br>7、抽象能力的几个层次：<br>     抽象的第一重，是将具体问题抽象成一个函数（或者类）用程序解决<br>     抽象的第二重，是撰写出可以解决多个问题的函数。解耦 范化 寻找共性<br>     抽象的第三重，是基础模型的建立。寻找共性和联系（这在我看来是领域建模）<br>     抽象的第四重，是制定规则，建立解决整个问题空间的一个世界，这就是元编程<br>8、以上几点纯属胡说八道、不要当真、因为每个人对抽象的理解有角度之分和程度之别</p>]]></content>
      
        <categories>
            
            <category> 胡说八道系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小议抽象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[The introduction of MongoDB]]></title>
      <url>/2017/09/15/The-introduction-of-MongoDB/</url>
      <content type="html"><![CDATA[<p> <img src="/images/mongoDB.png" alt=""><br> <a id="more"></a><br>    感谢在生命的最好的年华中，遇见了你—网易云音乐</p>
 <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=439915614&auto=0&height=66"></iframe>

<h1 id="MongoDB的发展"><a href="#MongoDB的发展" class="headerlink" title="MongoDB的发展"></a><strong>MongoDB的发展</strong></h1><p>2007年10月，MongoDB由10gen团队所发展。2009年2月首度推出、现在稳定版是3.4. <font color="red">现在社区非常繁荣</font></p>
<p>MongoDB是什么?<br>   1、MongoDB is an open-source document database that provides high performance, high availability, and automatic scaling.<br>   2、MongoDB 是由C++语言编写的,支持多种编程语言<br>   3、MongoDB 是一个面向集合的,模式自由的文档型数据库<br>   4、它在许多场景下可用于替代传统的关系型数据库或键/值存储方式</p>
<p>   主要特征：<br>      1、高性能 （数据模型有关、减少与数据库系统的I/O交互次数、内嵌和引用）<br>      2、丰富的查询语言 （CRUD、Data Aggregation、文件检索、地理空间查询）<br>      3、高可用性 （自动故障恢复、数据冗余）<br>      4、水平扩展能力 （分片）<br>      5、高性能 （多个存储引擎的支持 默认是WiredTiger）</p>
<p>   文档结构:<br>   MongoDB中的一条记录就是一个文档，是一个数据结构，由字段和值对组成。MongoDB文档与JSON对象类似。字段的值有可能包括其它文档、数组以及文档数组</p>
<p><img src="https://docs.mongodb.com/manual/_images/crud-annotated-document.bakedsvg.svg" alt=""></p>
<h1 id="BSON"><a href="#BSON" class="headerlink" title="BSON"></a><strong>BSON</strong></h1><p>在MongoDB中，文档是对数据的抽象，由于 MongoDB 支持嵌入文档、数组和哈希等多种复杂数据结构的使用，所以它最终将所有的数据以<font color="red"><strong>BSON</strong></font> 的数据格式存储起来<br>BSON是一个轻量级的二进制数据格式。MongoDB能够使用BSON，并将BSON作为数据存储存放在磁盘中。</p>
<font color="red"><strong>使用BSON格式出于以下3种目的：</strong></font>

<table>
<thead>
<tr>
<th>BSON特征</th>
<th>优势</th>
</tr>
</thead>
<tbody>
<tr>
<td><font color="red">效率</font></td>
<td>BSON是为效率而设计的，它只需要使用很少的空间。即使在最坏的情况下，BSON格式也比JSON格式在最好的情况下存储效率高。</td>
</tr>
<tr>
<td><font color="red">传输性</font></td>
<td>在某些情况下，BSON会牺牲额外的空间让数据的传输更加方便。比如，字符串的传输的前缀会标识字符串的长度，而不是在字符串的末尾打上结束的标记。这样的传输形式有利于MongoDB修改传输的数据。</td>
</tr>
<tr>
<td><font color="red">性能</font></td>
<td>最后，BSON格式的编码和解码都是非常快速的。它使用了C风格的数据表现形式，这样在各种语言中都可以高效地使用。</td>
</tr>
</tbody>
</table>
<p>更多关于BSON的介绍，可以参考：<a href="http://www.bsonspec.org" target="_blank" rel="external">http://www.bsonspec.org</a></p>
<h1 id="MongoDB架构"><a href="#MongoDB架构" class="headerlink" title="MongoDB架构"></a><strong>MongoDB架构</strong></h1><p>现有流行的数据库其实都有着非常相似的架构，MongoDB 其实就与 MySQL 中的架构相差不多，底层都使用了<font color="red">可插拔</font>的存储引擎以满足用户的不同需要<br><img src="/images/mongoDB架构.jpeg" alt=""><br>用户可以根据表中的数据特征选择不同的存储引擎，它们可以在同一个 MongoDB 的实例中使用；在最新版本的 MongoDB 中使用了 WiredTiger 作为默认的存储引擎，WiredTiger 提供了不同粒度的并发控制和压缩机制，能够为不同种类的应用提供了最好的性能和存储效率</p>
<h1 id="概念映射关系"><a href="#概念映射关系" class="headerlink" title="概念映射关系"></a><strong>概念映射关系</strong></h1><p><img src="/images/对比结构图.jpeg" alt=""></p>
<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a><strong>数据模型</strong></h1><p>1、存储在MongoDB中的数据有着非常灵活的Schema。我们不需要在插入数据之前就要定义好表中的数据结构，而且MongoDB不对Collection的数据结构进行任何限制，但是在实际使用中，同一个Collection中的大多数文档都具有类似的结构。<br><img src="/images/document.jpeg" alt=""><br>2、由于文档具有复杂的结构，所以在为MongoDB应用设计数据模型时，如何表示数据模型之间的关系其实是需要开发者需要仔细考虑的，这样才能利用MongoDB提供的诸多特性提升查询的效率，MongoDB 为表示文档之间的关系提供了两种不同的方法：<font color="red">引用和嵌入</font></p>
<p>引用(Reference):<br><img src="/images/引用.jpeg" alt=""><br>标准化的数据模型，类似mysql的外键，但是由于mongoDB不支持join，所以增加了客户端和MongoDB 之间的交互次数（Round-Trip）也会导致查询变慢，甚至非常严重的性能问题</p>
<p>嵌入(Embedded):<br><img src="/images/嵌入.jpeg" alt=""><br>不标准的数据模型,子文档是父文档的一个值<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  _id: &lt;ObjectId1&gt;,</div><div class="line">  username: "changfen",</div><div class="line">  age: 18,</div><div class="line">  contact: [</div><div class="line">    &#123;</div><div class="line">      _id: &lt;ObjectId2&gt;,</div><div class="line">      email: "changfen@2dfire.cn"</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>适用于包含关系的数据关系，例如用户与联系方式</p>
<h1 id="主键和索引"><a href="#主键和索引" class="headerlink" title="主键和索引"></a><strong>主键和索引</strong></h1><p>默认索引（主键）<br>MongoDB中所有的文档也都有一个唯一的 _id字段，在默认情况下所有的文档都使用一个长12字节的 ObjectId 作为默认索引：<br><img src="/images/objectId.jpeg" alt=""><br>前四位代表当前 _id 生成时的 Unix 时间戳，在这之后是三位的机器标识符和两位的处理器标识符，最后是一个三位的计数器，初始值就是一个随机数；通过这种方式代替递增的 id 能够解决分布式的 MongoDB 生成唯一标识符的问题，同时可以在一定程度上保证 id 的的增长是递增的。</p>
<p>mongoDB的索引与mysql的索引差不多，无论是底层的数据结构还是索引类型都几乎完全相同，只是mongoDB支持更多的索引种类<br><img src="/images/索引种类.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th>索引类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>单字段索引</td>
<td>db.users.createIndex( { age: -1 } )<br>db.users.createIndex( { age: 1 } )</td>
</tr>
<tr>
<td>复合索引</td>
<td>db.users.createIndex( { username: 1, age: -1 } )<br>db.users.createIndex( { username: 1, age: 1 } )</td>
</tr>
<tr>
<td>多键索引</td>
<td>db.collection.createIndex( { address: 1 } )<br>多键索引与单键索引创建形式相同，区别在于字段的值<br>单键索引：值为一个单一的值，例如字符串，数字或者日期，<br>多键索引：值具有多个记录，例如数组</td>
</tr>
<tr>
<td>文本索引</td>
<td>业务上更推荐Elasticsearch这种专业的搜索</td>
</tr>
<tr>
<td>地理位置索引</td>
<td>附近的店铺等</td>
</tr>
<tr>
<td>其他索引</td>
<td>有兴趣可以研究下</td>
</tr>
</tbody>
</table>
<h1 id="API例子"><a href="#API例子" class="headerlink" title="API例子"></a><strong>API例子</strong></h1><table>
<thead>
<tr>
<th>操作</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>db.inventory.insertOne(<br>{ item: “canvas”, qty: 100, tags: [“cotton”], size: { h: 28, w: 35.5, uom: “cm” } }<br>)</td>
<td>插入单条记录</td>
</tr>
<tr>
<td>插入多条</td>
<td>db.inventory.insertMany([<br>{ item: “journal”, qty: 25, size: { h: 14, w: 21, uom: “cm” }, status: “A” },<br>{ item: “notebook”, qty: 50, size: { h: 8.5, w: 11, uom: “in” }, status: “A” },<br>{ item: “paper”, qty: 100, size: { h: 8.5, w: 11, uom: “in” }, status: “D” },<br>{ item: “planner”, qty: 75, size: { h: 22.85, w: 30, uom: “cm” }, status: “D” },<br>{ item: “postcard”, qty: 45, size: { h: 10, w: 15.25, uom: “cm” }, status: “A” }<br>])</td>
<td>插入多条记录</td>
</tr>
<tr>
<td>查询</td>
<td>db.inventory.find( { item: “canvas” } )<br>db.inventory.find( { status: { $in: [ “A”, “D” ] } } )<br>db.inventory.find( { status: “A”, qty: { $lt: 30 } } )<br>db.inventory.find( { $or: [ { status: “A” }, { qty: { $lt: 30 } } ] } )</td>
<td>查询<br>SELECT <em> FROM inventory WHERE item = “canvas”<br>SELECT </em> FROM inventory WHERE status in (“A”, “D”)<br>SELECT <em> FROM inventory WHERE status = “A” AND qty &lt; 30<br>SELECT </em> FROM inventory WHERE status = “A” OR qty &lt; 30</td>
</tr>
</tbody>
</table>
<p>以上只是一些简单的例子，mongoDB语法非常丰富，而且提供了几乎世面上所有流行的编程语言的API</p>
<h1 id="Morphia"><a href="#Morphia" class="headerlink" title="Morphia"></a><strong>Morphia</strong></h1><p>由于mongoDB语法不太友好（特别对于我们java开发者），所以推荐Morphia这个官方版的ODM工具</p>
<h1 id="MongoDB应用场景"><a href="#MongoDB应用场景" class="headerlink" title="MongoDB应用场景"></a><strong>MongoDB应用场景</strong></h1><p>1、游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新<br>2、物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。<br>3、社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能<br>4、物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析<br>5、视频直播，使用 MongoDB 存储用户信息、礼物信息等<br>6、······等等<br><img src="/images/应用场景.dms" alt=""></p>
<h1 id="MongoDB的优点与缺点"><a href="#MongoDB的优点与缺点" class="headerlink" title="MongoDB的优点与缺点"></a><strong>MongoDB的优点与缺点</strong></h1><table>
<thead>
<tr>
<th>MongoDB特性</th>
<th>优势</th>
</tr>
</thead>
<tbody>
<tr>
<td>事务支持</td>
<td>MongoDB目前只支持单文档事务，需要复杂事务支持的场景暂时不适合</td>
</tr>
<tr>
<td>灵活的文档模型</td>
<td>JSON格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代</td>
</tr>
<tr>
<td>高可用复制集</td>
<td>满足数据高可靠、服务高可用的需求，运维简单，故障自动切换</td>
</tr>
<tr>
<td>可扩展分片集群</td>
<td>海量数据存储，服务能力水平扩展</td>
</tr>
<tr>
<td>高性能</td>
<td>mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足各种场景需求</td>
</tr>
<tr>
<td>强大的索引支持</td>
<td>地理位置索引可用于构建各种O2O 应用、文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求</td>
</tr>
<tr>
<td>Gridfs</td>
<td>解决文件存储的需求</td>
</tr>
<tr>
<td>aggregation &amp; mapreduce</td>
<td>解决数据分析场景需求，用户可以自己写查询语句或脚本，将请求都分发到 MongoDB 上完成</td>
</tr>
</tbody>
</table>
<p>1、厂商的噱头，并不是说NoSQL一定比关系型数据库好，因为数据库的性能不止与数据库本身的设计有关系，还与开发者对表结构和索引的设计、存储引擎的选择和业务有着巨大的关系!<br>2、MongoDB布道者TJ博士设计了几个选择题来辅助我们是否应该使用MongoDB</p>
<table>
<thead>
<tr>
<th>应用特征</th>
<th>YES / NO</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用不需要事务及复杂join支持</td>
<td>Yes</td>
</tr>
<tr>
<td>新应用，需求会变，数据模型无法确定，想快速迭代开发</td>
<td>？</td>
</tr>
<tr>
<td>应用需要2000-3000以上的读写QPS（更高也可以）</td>
<td>？</td>
</tr>
<tr>
<td>应用需要TB甚至 PB 级别数据存储</td>
<td>?</td>
</tr>
<tr>
<td>应用发展迅速，需要能快速水平扩展</td>
<td>?</td>
</tr>
<tr>
<td>应用要求存储的数据不丢失</td>
<td>?</td>
</tr>
<tr>
<td>应用需要99.999%高可用</td>
<td>?</td>
</tr>
<tr>
<td>应用需要大量的地理位置查询、文本查询</td>
<td>？</td>
</tr>
</tbody>
</table>
<p>如果上述有1个 Yes，可以考虑 MongoDB，2个及以上的 Yes，选择 MongoDB 绝不会后悔</p>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a><strong>扩展阅读</strong></h1><p>1、WiredTiger存储引擎实现<br>2、MongoDB 复制集原理实现</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h1><p><a href="https://docs.mongodb.com/manual/?_ga=2.190019746.885390148.1505483057-1629220430.1505483057" target="_blank" rel="external">MongoDB官方文档</a><br><a href="https://www.mongodb.com/zh/mongodb-architecture" target="_blank" rel="external">MongoDB架构指南</a></p>
<h1 id="干货"><a href="#干货" class="headerlink" title="干货"></a><strong>干货</strong></h1><p><img src="/images/波多老师.jpeg" alt=""></p>]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[致橡树]]></title>
      <url>/2017/08/10/%E8%87%B4%E6%A9%A1%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>我觉得这首诗挺美的，就贴过来了！</p>
<a id="more"></a>
<p><img src="/images/小红.jpeg" alt="致橡树"></p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=489998494&auto=1&height=66"></iframe><br>致橡树<br>我如果爱你——<br>　　绝不像攀援的凌霄花，<br>　　借你的高枝炫耀自己；<br>　　我如果爱你——<br>　　绝不学痴情的鸟儿，<br>　　为绿荫重复单调的歌曲；<br>　　也不止像泉源，<br>　　常年送来清凉的慰藉；<br>　　也不止像险峰，<br>　　增加你的高度，衬托你的威仪。<br>　　甚至日光，<br>　　甚至春雨。<br>    不，这些都还不够！<br>　　我必须是你近旁的一株木棉，<br>　　作为树的形象和你站在一起。<br>　　根，紧握在地下；<br>　　叶，相触在云里。<br>　　每一阵风过，<br>　　我们都互相致意，<br>　　但没有人，<br>　　听懂我们的言语。<br>　　你有你的铜枝铁干，<br>　　像刀，像剑，也像戟；<br>　　我有我红硕的花朵，<br>　　像沉重的叹息，<br>　　又像英勇的火炬。<br>   我们分担寒潮、风雷、霹雳；<br>　　我们共享雾霭、流岚、虹霓。<br>　　仿佛永远分离，<br>　　却又终身相依。<br>　　这才是伟大的爱情，<br>　　坚贞就在这里：<br>　　爱——<br>　　不仅爱你伟岸的身躯，<br>　　也爱你坚持的位置，<br>　　足下的土地。</p>]]></content>
      
        <categories>
            
            <category> 诗词歌赋 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 花前月下 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[奇怪！为什么一个线程能访问到一个没有被初始化的对象？]]></title>
      <url>/2017/08/10/%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%BA%86%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>   难道你就不奇怪，没有被初始化的对象是怎么出现的吗？😳<br><a id="more"></a><br>   如果一个对象的初始化操作非常昂贵，这时候可以考虑<font color="red"><strong>Lazy Initialization</strong></font>。<br>   比如获取数据库连接资源、APP启动速度过慢等。<br>   但是要实现线程安全的Lazy Initialization需要一些技巧。<br>）</p>
<p>我们先来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitializationDemo</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">//1：A线程执行</span></div><div class="line">           instance = <span class="keyword">new</span> Instance(); <span class="comment">//2：B线程执行</span></div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假如静态方法getInstance()被两个线程A和B访问、当A执行到1的时候可能条件语句是false的，直接返回了还未被初始化instance，后续用这个instance处理一些逻辑就会出现不可预知的问题了。</p>
<p>问题大概知道了，那有什么办法解决呢？<br>1、synchronized同步：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeLazyInitializationDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</div><div class="line">            instance = <span class="keyword">new</span> Instance();</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<font color="green">synchronized将导致性能开销。如果getInstance()被多个线程频繁的调用，将会导致程序执行性能的下降</font>

</blockquote>
<p>2、进阶方案：double-checked locking<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLockingDemo</span> </span>&#123;                  <span class="comment">//1</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;                    <span class="comment">//2</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;               <span class="comment">//3</span></div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                          <span class="comment">//4:第一次检查</span></div><div class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLocking.class) &#123;  <span class="comment">//5:加锁</span></div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)                    <span class="comment">//6:第二次检查</span></div><div class="line">                    instance = <span class="keyword">new</span> Instance();           <span class="comment">//7:问题的根源出在这里</span></div><div class="line">            &#125;                                            <span class="comment">//8</span></div><div class="line">        &#125;                                                <span class="comment">//9</span></div><div class="line">        <span class="keyword">return</span> instance;                                 <span class="comment">//10</span></div><div class="line">    &#125;                                                    <span class="comment">//11</span></div><div class="line">&#125;                                                        <span class="comment">//12</span></div></pre></td></tr></table></figure></p>
<p>但是在执行到4的时候，和UnsafeLazyInitializationDemo有同样的问题。</p>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>为什么会产生这样的现象呢？那是因为JVM对new操作的处理过程如下：</p>
<font color="red">1、memory = allocate();     //1：分配对象的内存空间<br>2、ctorInstance(memory);    //2：初始化对象<br>3、instance = memory;       //3：设置instance指向刚分配的内存地址</font>

<p>其中2和3可以指令重排序、单线程指令重排序可以提高性能</p>
<blockquote>
<p><font color="red"><em>The Java Language Specification, Java SE 7 Edition</em></font> 的intra-thread semantics规则保证重排序不会改变单线程内的程序执行结果</p>
</blockquote>
<p>但是多线程就不能保证了！</p>
<p>问题根源：<br>1、不允许2和3重排序；<br>2、允许2和3重排序，但不允许其他线程“看到”这个重排序。<br>我们可以想出两个办法来实现线程安全的延迟初始化：</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="基于volatile的double-checked-locking的解决方案"><a href="#基于volatile的double-checked-locking的解决方案" class="headerlink" title="基于volatile的double-checked locking的解决方案"></a>基于volatile的double-checked locking的解决方案</h2><p>原理：不允许2和3重排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLockingDemo</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</div><div class="line">                    instance = <span class="keyword">new</span> Instance();<span class="comment">//instance为volatile，现在没问题了</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h2><p>原理：允许2和3重排序，但不允许其他线程“看到”这个重排序</p>
<blockquote>
<p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。<br>有兴趣可以看看JVM的类加载过程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> InstanceHolder.instance ;  <span class="comment">//这里将导致InstanceHolder类被初始化</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化一个类，包括执行这个类的静态初始化和初始化在这个类中声明的静态字段。根据java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：</p>
<blockquote>
<p>1、T是一个类，而且一个T类型的实例被创建；<br>2、T是一个类，且T中声明的一个静态方法被调用；<br>3、T中声明的一个静态字段被赋值；<br>4、T中声明的一个静态字段被使用，而且这个字段不是一个常量字段；<br>5、T是一个顶级类（top level class，见java语言规范的§7.6），而且一个断言语句嵌套在T内部被执行。</p>
</blockquote>
<p>在ClassLoaderDemo示例代码中，首次执行getInstance()的线程将导致InstanceHolder类被初始化（符合情况4）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案</p>
<blockquote>
<font color="red">Effective Java 建议慎用Lazy Initialization</font>

</blockquote>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>1、单例模式<br>2、JVM类加载<br>3、synchronized关键字<br>4、volatile关键字</p>]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Effective Java </tag>
            
            <tag> 面向模式的软件体系架构卷三中Lazy Acquisition模式 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
