<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[我对抽象的理解]]></title>
      <url>/2017/11/30/%E6%88%91%E5%AF%B9%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><font color="red" size="6"><strong>郑重声明：本文有误人子弟之嫌，概不负责！胡说八道正式开始～～～</strong></font><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>&emsp;&emsp;软件设计经常会被拿来和建筑设计去对比、但其实软件设计和它们的区别很大、那就是成型之后，需求是不停的变化、设计是需要响应这些变化的。你有听说过一座竣工的大厦，过一段时间要新加一个楼层就能往上加吗？不能！因为蓝图在设计之初就已经设计不变了，即不支持扩展性！所以软件设计后期随着需求的不停变化、复杂度逐步上升、往往新加一个小功能就影响全局！所以要求我们在软件设计之初就要考虑好后期的扩展性，而抽象无疑是必由之路。抽象本身并不能解决问题，通过抽象能简化和分解问题，使之更容易理解和控制，相应的解法也更具稳定性、普适性、重用性和可维护性。</p>
<h1 id="抽象的定义"><a href="#抽象的定义" class="headerlink" title="抽象的定义"></a><strong>抽象的定义</strong></h1><p>1、广义：抽象是人类认识和描绘世界最首要的工具！<br>2、狭义：抽象就是作减法和除法 </p>
<table>
<thead>
<tr>
<th>概念</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>减法：</td>
<td>去粗取精</td>
</tr>
<tr>
<td>除法：</td>
<td>异中求同、同类归并</td>
</tr>
<tr>
<td>结果：</td>
<td>大数变小数、复杂变简单</td>
</tr>
</tbody>
</table>
<h1 id="抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色"><a href="#抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色" class="headerlink" title="抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色"></a><strong>抽象贯穿OOA、OOD、OOP三个阶段，扮演着不同的角色</strong></h1><p>在软件工程中，系统开发生命周期最核心的有三个阶段：分析、设计、实现。对应对象导向式的方法：OOA、OOD、OOP</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>关注点</th>
<th>操作</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>OOA</td>
<td>概念模型</td>
<td>领域分析、应用分析、制定功能规范</td>
<td>以对象为中心</td>
</tr>
<tr>
<td>OOD</td>
<td>数学模型</td>
<td>制定实现规范</td>
<td>以接口为中心</td>
</tr>
<tr>
<td>OOP</td>
<td>数据结构</td>
<td>编码</td>
<td>以数据为中心</td>
</tr>
</tbody>
</table>
<hr>
<p>贯穿这3个阶段的主线正是抽象、并且抽象程度依次递减。</p>
<h1 id="抽象机制"><a href="#抽象机制" class="headerlink" title="抽象机制"></a><strong>抽象机制</strong></h1><p>常用两种抽象：参数抽象、规范抽象</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数抽象</td>
<td>形参</td>
</tr>
<tr>
<td>规范抽象</td>
<td>先验条件、后验条件<br>规范说明：功能与实现相分离的方法称为规范抽象</td>
</tr>
</tbody>
</table>
<h1 id="契约式设计与防御式编程"><a href="#契约式设计与防御式编程" class="headerlink" title="契约式设计与防御式编程"></a><strong>契约式设计与防御式编程</strong></h1><p>有了参数抽象和规范抽象并不能保证设计出一个良好的接口，所以出现了契约式设计<br>契约式设计的定义：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>性质</th>
<th>语言支持</th>
<th>特点</th>
<th>功效</th>
</tr>
</thead>
<tbody>
<tr>
<td>契约式设计</td>
<td>先君子后小人</td>
<td>异常机制和断言</td>
<td>职责清晰</td>
<td>保障程序的正确性</td>
</tr>
<tr>
<td>防御性编程</td>
<td>先小人后君子</td>
<td>任何语言都支持</td>
<td>职责不清晰</td>
<td>保障程序的健壮性</td>
</tr>
</tbody>
</table>
<p>两种方式相辅相成，保证软件系统的可靠性！</p>
<h1 id="五类基本抽象"><a href="#五类基本抽象" class="headerlink" title="五类基本抽象"></a><strong>五类基本抽象</strong></h1><table>
<thead>
<tr>
<th>抽象类型</th>
<th>能力</th>
<th>说明</th>
<th>抽象引入</th>
<th>抽象结果</th>
<th>抽象目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>过程抽象</td>
<td>赋予程序员自定义运算的能力</td>
<td>过程范式</td>
<td>运算</td>
<td>函数</td>
<td>将行为的逻辑属性与实现细节分离</td>
</tr>
<tr>
<td>数据抽象</td>
<td>赋予程序员自定义类型的能力</td>
<td>OOP的起源</td>
<td>类型</td>
<td>抽象数据类型</td>
<td>将数据的逻辑属性与表示细节分离</td>
</tr>
<tr>
<td>迭代抽象</td>
<td>赋予程序员自定义循环的能力</td>
<td>泛型范式的迭代器</td>
<td>循环</td>
<td>迭代器</td>
<td>将集合遍历与元素的获取细节分离</td>
</tr>
<tr>
<td>类型层级</td>
<td>赋予程序员自定义类族的能力</td>
<td>对象范式中的继承</td>
<td>类族</td>
<td>类型层级结构</td>
<td>将类型家族的公共行为与具体类型分离</td>
</tr>
<tr>
<td>多态抽象</td>
<td>赋予程序员自定义多态类型的能力</td>
<td>对象范式与泛型范式中的多态</td>
<td>多态类型</td>
<td>抽象类型（OOP）<br>参数类型（GP）</td>
<td>将类型的接口规范与实现代码分离<br>将类型与算法分离</td>
</tr>
</tbody>
</table>
<h1 id="数据抽象—OOP的核心和起源"><a href="#数据抽象—OOP的核心和起源" class="headerlink" title="数据抽象—OOP的核心和起源"></a><strong>数据抽象—OOP的核心和起源</strong></h1><p>&emsp;&emsp;首先我们介绍一个重要的概念，抽象数据类型（ADT）,如果一个数据类型依赖于具体实现，它就是具体（DTO），反之则是抽象（queue）。<font color="red">它关心的是抽象接口而不是具体实现。</font><br>&emsp;&emsp;现在举个例子来说明数据抽象，队列queue想必大家都比较清楚了，无论底层是用数组实现还是列表实现，其实用户根本不需关心，<font color="red">这便是队列的抽象所在</font>—用户不应知道 也不必知道它的具体实现,只能通过指定接口来进行‘暗箱操作’。这样经过数据抽象，队列的本质特征由API展现,非本质特征则屏蔽于客户的视野之外。</p>
<blockquote>
<blockquote>
<p><font color="red">结论</font>：参数抽象使得数据接口普适化，规范抽象使得数据接口契约化。一个完整的数据抽象除了对每个接口作规范说明外，还须对该数据类型作整体规范说明，OOP中的类注释文档即作此用。有了整体的规范描述，一个抽象数据类型才能真正在客户头脑中抽象化和概念化！</p>
</blockquote>
</blockquote>
<h1 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a><strong>封装、继承、多态</strong></h1><p>抽象（尤其数据抽象）是OOP的核心和起源，是封装、继承和多态的基础。下面从这三个方面来理解抽象<br>1、封装是什么？<br>&emsp;&emsp;将数据与行为包装在一起，这只是广义上的封装—打包！狭义上封装是在打包的基础上加上访问控制，以实现信息隐藏(掩盖实现细节)。</p>
<blockquote>
<blockquote>
<p>1、抽象意味着用户可以从高层的接口来看待或使用一类对象，而不用关心它底层的实现，而封装意味着用户不需要也无权访问底层的实现。”<br>  2、要记住信息隐藏是原则，封装只是一种实现方式</p>
</blockquote>
</blockquote>
<p>2、继承是什么？<br>&emsp;&emsp;子类继承父类或者子类遗传父类这两种说法其实都是不准确的，我所理解的继承是一种泛化关系。子类通过泛化得到父类，这是一种概念抽象的过程；父类通过特化得到子类。这是一种概念细化的过程；在设计过程中两种设计往往交替使用—–<strong>而这就是五种基本抽象之一类型层级</strong>。特别要注意：某些教科书上用衍生关系去描述继承关系是不对，这个真的是误人子弟，稍后带来例子<br>&emsp;&emsp;常见的继承有两种：类继承和接口继承。那继承的作用是什么?在回答这个问题之前，还要再问一个问题，面向对象编程中，最重要的思想是什么？是封装？是继承？是多态吗？都不对！应该是代码重用，严格来说应该是代码被重用。所以现在知道继承的作用是什么了吧？<br>&emsp;&emsp;类继承很好理解代码重用的观点，可以重用父类的代码，但是接口继承怎么重用？实现代码都没有啊！<br>&emsp;&emsp;抽象接口是控制反转的关键，通过抽象出一系列接口，并在这些接口上进行操作，使得控制逻辑不依赖于具体的实现；同时，具体的实现可以并不关心控制逻辑如何使用自己，它们会在需要的时候被调用。由此，使用对象的逻辑和对象本身充分解耦，由接口这座桥梁将二者联系起来。这样，代码得到了最大程度的被重用。是不是有点眼熟？没错，这就是面向接口编程的由来！</p>
<blockquote>
<blockquote>
<p><strong>实现继承消费可重用的旧代码，接口继承生产可重用的新代码</strong></p>
</blockquote>
</blockquote>
<p>谈到接口继承，不得不提 Liskov substitution principle（里氏变换原则），wikipedia 这样介绍它：</p>
<blockquote>
<blockquote>
<p>It states that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S.</p>
</blockquote>
</blockquote>
<p>这也是面向对象编程中常说的Substitutability（可替换性）。这段话翻译过来说就是，在类型系统中，如果类型S是类型T的子类型，那么类型T的任意对象可以被类型S的对象替换，且不影响程序的正确性。里氏变换是面向对象编程（其实适用于任何编程思想）非常重要的一个原则，也是程序得以多态的基石。如果我们做一个系统，要注意尽一切可能满足这一原则。</p>
<p>现在我们来举个经典例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bird</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;<span class="comment">//鸟会飞</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lay</span><span class="params">()</span></span>;<span class="comment">//鸟会下蛋</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> <span class="keyword">implements</span> <span class="title">Bird</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"企鹅不会飞"</span>)  </div><div class="line">  &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//企鹅会走路</span></div><div class="line">  &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lay</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//企鹅会下蛋</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//客户代码</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letGo</span><span class="params">(Bird bird)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (bird <span class="keyword">instanceof</span> Penguin)&#123;</div><div class="line">      ((Penguin)bird).walk(); </div><div class="line">    &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    bird.fly();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于企鹅是一种鸟，因此继承了Bird，为此不得不实现fly方法。但企鹅并不会飞，只好抛出UnsupportedOperationException的异常。其后果是客户代码不得不为这种特殊类型作特别处理，否则整个流程会被破坏。 类似地，如果还存在一个Ostrich类，由于鸵鸟不会飞只会跑，以上客户代码又得变成这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letGo</span><span class="params">(Bird bird)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (bird <span class="keyword">instanceof</span> Penguin)&#123;</div><div class="line">      ((Penguin)bird).walk(); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (bird <span class="keyword">instanceof</span> Ostrich)&#123;</div><div class="line">    ((Ostrich)bird).run();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    bird.fly();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这严重违反OCP原则,因为它对修改不是封闭的，以后代码为了兼容会越来越难看，这就是符合我们的生活逻辑但是不符合LSP设计的例子，所以用衍生关系去理解继承关系是有问题的，这就是一种蹩脚的设计！</p>
<blockquote>
<blockquote>
<p>接口继承是为了代码被重用，但是必须建立在LSP原则之上！</p>
</blockquote>
</blockquote>
<p>错就错在不应该把Penguin和Ostrich当作Bird的子类型，至于解决方案，大家可以想想～～</p>
<blockquote>
<blockquote>
<p>继承的主要作用：通过实现继承完成代码重用；通过接口继承完成代码被重用；建立概念的分类体系。</p>
</blockquote>
</blockquote>
<p>至于怎么合理使用继承，这里就不介绍了，内容太多，没准备，有趣兴可以看看JDK设计的Properties～～～主要还是大家多多思考！</p>
<p>3、多态是什么？<br>多态是动静结合的产物，将静态类型的安全性和动态类型的灵活性融为一体。<br>静态类型语言中一般有两种实现方式： </p>
<blockquote>
<blockquote>
<p>一种利用GP（泛型编程）中的参数多态（parametric polymorphism）。<br>一种利用OOP中的包含多态（inclusion polymorphism）或称子类型多态（subtyping polymorphism）。</p>
</blockquote>
</blockquote>
<p>参数多态：让相同的实现代码应用于不同的场合<br>包含多态：让不同的实现代码应用于相同的场合<br>多态机制是保证代码的灵活性、可维护性和可重用性的终极武器。</p>
<p>举例子说明下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**一个可以验证用户名和密码的类*/</span> </div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Authenticator</span> </span>&#123;</div><div class="line"> <span class="comment">/**保存用户名和密码 */</span> </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span>  <span class="keyword">void</span> <span class="title">save</span><span class="params">( String user, String password)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</div><div class="line">      password = <span class="string">""</span>;</div><div class="line">  &#125; </div><div class="line">  store(user,encrypt(password)); </div><div class="line">  &#125; </div><div class="line">  <span class="comment">/**验证用户名和密码*/</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span>  <span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">( String user, String password)</span> </span>&#123; </div><div class="line">     String storedPassword = retrieve( user); </div><div class="line">     <span class="keyword">if</span> (storedPassword == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>; </div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</div><div class="line">         password = <span class="string">""</span>; </div><div class="line">       &#125;</div><div class="line">     <span class="keyword">return</span> storedPassword. equals( encrypt( password)); </div><div class="line">   &#125; </div><div class="line">  <span class="comment">/** 保存用户名和加密过的密码 */</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">( String user, String encryptedPassword)</span></span>; </div><div class="line">  <span class="comment">/** 从用户名获取相应的加密过的密码 */</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">retrieve</span><span class="params">( String user)</span></span>; </div><div class="line">  <span class="comment">/**给明文单向加密，默认不加密 */</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">encrypt</span><span class="params">( String text)</span> </span>&#123; </div><div class="line">       <span class="keyword">return</span> text; </div><div class="line">      &#125; </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>我们可能会这样用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 一个简单的验证类，数据放在内存，密码保持明文 */</span></div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAuthenticator</span> <span class="keyword">extends</span> <span class="title">Authenticator</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Map&lt; String, String&gt; usrPwd = <span class="keyword">new</span> HashMap&lt; String, String&gt;(); </div><div class="line"></div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">( String user, String encryptedPassword)</span> </span>&#123; </div><div class="line">      usrPwd.put( user, encryptedPassword); </div><div class="line">    &#125; </div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">retrieve</span><span class="params">( String user)</span> </span>&#123; </div><div class="line">      <span class="keyword">return</span> usrPwd.get( user); </div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这时候考虑到加密方式，我们可能会这样用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**一个安全的验证类，数据放在内存，密码经过SHA-1加密 */</span> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShalAuthenticator</span> <span class="keyword">extends</span> <span class="title">SimpleAuthenticator</span> </span>&#123; </div><div class="line"><span class="comment">// SHA-1算法 </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"SHA- 1"</span>; </div><div class="line"><span class="comment">// 避免依赖平台 </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF- 8"</span>; </div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">encrypt</span><span class="params">( String plainText)</span></span>&#123; </div><div class="line">   <span class="keyword">try</span> &#123; </div><div class="line">       MessageDigest md = MessageDigest.getInstance(ALGORITHM); </div><div class="line">       md.update(plainText.getBytes(CHARSET)); </div><div class="line">       <span class="keyword">byte</span> digest[] = md. digest(); </div><div class="line">       <span class="comment">//为简便起见用到了非标准的API,因此以下代码有警告 </span></div><div class="line">       <span class="keyword">return</span> (<span class="keyword">new</span> BASE64Encoder()).encode( digest);</div><div class="line">    &#125;<span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.getMessage()); </div><div class="line">      &#125; </div><div class="line">     <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; </div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.getMessage()); </div><div class="line">      &#125; </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAuthenticator</span> </span>&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args)</span> </span>&#123; </div><div class="line">     test( <span class="keyword">new</span> SimpleAuthenticator());</div><div class="line">     test( <span class="keyword">new</span> Sha1Authenticator()); </div><div class="line">    &#125; </div><div class="line">   </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">( Authenticator authenticator)</span> </span>&#123; </div><div class="line">     <span class="comment">//子类型多态：让不同的实现代码应用于相同的场合</span></div><div class="line">     test(authenticator, <span class="string">"user"</span>, <span class="string">"password"</span>); </div><div class="line">     test(authenticator, <span class="string">"user"</span>, <span class="string">"newPassword"</span>); </div><div class="line">     test(authenticator, <span class="string">"admin"</span>, <span class="string">"admin"</span>); </div><div class="line">     test(authenticator, <span class="string">"guest"</span>, <span class="keyword">null</span>); </div><div class="line">     test(authenticator, <span class="keyword">null</span>, <span class="string">"pass"</span>); </div><div class="line">     authenticator.save(<span class="string">"scott"</span>, <span class="string">"tiger"</span>); </div><div class="line">     <span class="comment">//大小写敏感 </span></div><div class="line">     <span class="keyword">assert</span>(!authenticator.authenticate(<span class="string">"scott"</span>, <span class="string">"TIGER"</span>)); </div><div class="line">     <span class="comment">//大小写敏感 </span></div><div class="line">     <span class="keyword">assert</span>(!authenticator.authenticate(<span class="string">"SCOTT"</span>, <span class="string">"tiger"</span>)); &#125; </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Authenticator authenticator, String user, String password)</span></span>&#123; </div><div class="line">     authenticator.save(user,password);</div><div class="line">     <span class="keyword">assert</span>(authenticator.authenticate(user, password)); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是模版方法：固定整体框架和流程以保证可重用性，留出一些子类定制点以保证可扩展性。<br>下面再给出一个更好的设计：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//键值对的存取接口 </span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">KeyValueKeeper</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">( String key, String value)</span></span>; </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">retrieve</span><span class="params">( String key)</span></span>; </div><div class="line">&#125;</div><div class="line"><span class="comment">//加密接口 </span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Encrypter</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">( String plainText)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authenticator</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> KeyValueKeeper keeper; </div><div class="line">  <span class="keyword">private</span> Encrypter encrypter; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Authenticator</span><span class="params">( KeyValueKeeper keeper, Encrypter encrypter)</span> </span>&#123; </div><div class="line">    <span class="keyword">this</span>.keeper = keeper; </div><div class="line">    <span class="keyword">this</span>.encrypter = encrypter; </div><div class="line">  &#125; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">( String user, String password)</span> </span>&#123; </div><div class="line">    <span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</div><div class="line">       password = <span class="string">""</span>; </div><div class="line">    &#125;  </div><div class="line">     keeper.store(user, encrypter. encrypt( password));</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">authenticate</span><span class="params">( String user, String password)</span> </span>&#123; </div><div class="line">     String storedPassword = keeper. retrieve( user); </div><div class="line">     <span class="keyword">if</span> (storedPassword == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; </div><div class="line">     <span class="keyword">if</span> (password == <span class="keyword">null</span>) password = <span class="string">""</span>; </div><div class="line">     <span class="keyword">return</span> storedPassword. equals( encrypter.encrypt( password)); </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryKeeper</span> <span class="keyword">implements</span> <span class="title">KeyValueKeeper</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> Map&lt; String, String&gt; keyValue = <span class="keyword">new</span> HashMap&lt; String, String&gt;(); </div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">( String key, String value)</span> </span>&#123; </div><div class="line">    keyValue. put( key, value); </div><div class="line">  &#125; </div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">retrieve</span><span class="params">( String key)</span> </span>&#123; </div><div class="line">    <span class="keyword">return</span> keyValue. get( key); </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainEncrypter</span> <span class="keyword">implements</span> <span class="title">Encrypter</span> </span>&#123; </div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">( String plainText)</span> </span>&#123; </div><div class="line">    <span class="keyword">return</span> plainText;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sha1Encrypter</span> <span class="keyword">implements</span> <span class="title">Encrypter</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"SHA- 1"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF- 8"</span>;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">( String plainText)</span> </span>&#123; </div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      MessageDigest md = MessageDigest.getInstance(ALGORITHM);</div><div class="line">      md.update( plainText.getBytes(CHARSET)); </div><div class="line">      <span class="keyword">byte</span> digest[] = md.digest();</div><div class="line">      <span class="keyword">return</span>(<span class="keyword">new</span> BASE64Encoder()).encode(digest); </div><div class="line">      &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123; </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.getMessage()); </div><div class="line">      &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; </div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.getMessage()); </div><div class="line">      &#125; </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAuthenticator</span> </span>&#123; </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args)</span> </span>&#123;</div><div class="line">   test( <span class="keyword">new</span> Authenticator( <span class="keyword">new</span> MemoryKeeper(), <span class="keyword">new</span> PlainEncrypter())); </div><div class="line">   test( <span class="keyword">new</span> Authenticator( <span class="keyword">new</span> MemoryKeeper(), <span class="keyword">new</span> Sha1Encrypter())); </div><div class="line">   &#125; </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">( Authenticator authenticator)</span> </span>&#123;</div><div class="line">    <span class="comment">//同上</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是策略模式。</p>
<h1 id="万人迷的类"><a href="#万人迷的类" class="headerlink" title="万人迷的类"></a><strong>万人迷的类</strong></h1><p>一个万人迷的类一定充分体现ADT思想的类：有优雅的外形—抽象，有丰富的内涵—数据，有鲜明的个性—类型<br><img src="/images/ADT.jpeg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>&emsp;&emsp;抽象能力不止是程序员应该去关注的，其他的行业人员也应该去关注的，因为它能帮助我们简化问题、解决问题<br>但是说了这么多，至于怎么提升却还是显得那么“抽象”，借用下Bob大叔的话：“阅读代码—&gt;而且是阅读大量的优秀代码”，不停的实践。<br>我们程序员平常的工作大抵就是理解业务需求，开始设计，编码实现，维护等，能设计出一个符合参数抽象和规范抽象的接口就是一个难得的程序员了！<br>其实技术和业务哪个重要？我觉得就像语言之争，并没有什么大的意义，我觉得是相辅相成的，业务理解力强有助于技术实现，而技术强能更快的、更好的实现业务需求<br>以上几点纯属胡说八道、不要当真、因为每个人对抽象的理解有角度之分和程度之别</p>]]></content>
      
        <categories>
            
            <category> 胡说八道系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小议抽象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[奇怪！为什么一个线程能访问到一个没有被初始化的对象？]]></title>
      <url>/2017/08/10/%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%BA%86%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>   难道你就不奇怪，没有被初始化的对象是怎么出现的吗？😳<br><a id="more"></a><br>   如果一个对象的初始化操作非常昂贵，这时候可以考虑<font color="red"><strong>Lazy Initialization</strong></font>。<br>   比如获取数据库连接资源、APP启动速度过慢等。<br>   但是要实现线程安全的Lazy Initialization需要一些技巧。<br>）</p>
<p>我们先来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeLazyInitializationDemo</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">//1：A线程执行</span></div><div class="line">           instance = <span class="keyword">new</span> Instance(); <span class="comment">//2：B线程执行</span></div><div class="line">      <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假如静态方法getInstance()被两个线程A和B访问、当A执行到1的时候可能条件语句是false的，直接返回了还未被初始化instance，后续用这个instance处理一些逻辑就会出现不可预知的问题了。</p>
<p>问题大概知道了，那有什么办法解决呢？<br>1、synchronized同步：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeLazyInitializationDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</div><div class="line">            instance = <span class="keyword">new</span> Instance();</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<font color="green">synchronized将导致性能开销。如果getInstance()被多个线程频繁的调用，将会导致程序执行性能的下降</font>

</blockquote>
<p>2、进阶方案：double-checked locking<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLockingDemo</span> </span>&#123;                  <span class="comment">//1</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;                    <span class="comment">//2</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;               <span class="comment">//3</span></div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                          <span class="comment">//4:第一次检查</span></div><div class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLocking.class) &#123;  <span class="comment">//5:加锁</span></div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)                    <span class="comment">//6:第二次检查</span></div><div class="line">                    instance = <span class="keyword">new</span> Instance();           <span class="comment">//7:问题的根源出在这里</span></div><div class="line">            &#125;                                            <span class="comment">//8</span></div><div class="line">        &#125;                                                <span class="comment">//9</span></div><div class="line">        <span class="keyword">return</span> instance;                                 <span class="comment">//10</span></div><div class="line">    &#125;                                                    <span class="comment">//11</span></div><div class="line">&#125;                                                        <span class="comment">//12</span></div></pre></td></tr></table></figure></p>
<p>但是在执行到4的时候，和UnsafeLazyInitializationDemo有同样的问题。</p>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>为什么会产生这样的现象呢？那是因为JVM对new操作的处理过程如下：</p>
<font color="red">1、memory = allocate();     //1：分配对象的内存空间<br>2、ctorInstance(memory);    //2：初始化对象<br>3、instance = memory;       //3：设置instance指向刚分配的内存地址</font>

<p>其中2和3可以指令重排序、单线程指令重排序可以提高性能</p>
<blockquote>
<p><font color="red"><em>The Java Language Specification, Java SE 7 Edition</em></font> 的intra-thread semantics规则保证重排序不会改变单线程内的程序执行结果</p>
</blockquote>
<p>但是多线程就不能保证了！</p>
<p>问题根源：<br>1、不允许2和3重排序；<br>2、允许2和3重排序，但不允许其他线程“看到”这个重排序。<br>我们可以想出两个办法来实现线程安全的延迟初始化：</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="基于volatile的double-checked-locking的解决方案"><a href="#基于volatile的double-checked-locking的解决方案" class="headerlink" title="基于volatile的double-checked locking的解决方案"></a>基于volatile的double-checked locking的解决方案</h2><p>原理：不允许2和3重排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLockingDemo</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</div><div class="line">                    instance = <span class="keyword">new</span> Instance();<span class="comment">//instance为volatile，现在没问题了</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h2><p>原理：允许2和3重排序，但不允许其他线程“看到”这个重排序</p>
<blockquote>
<p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。<br>有兴趣可以看看JVM的类加载过程。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> InstanceHolder.instance ;  <span class="comment">//这里将导致InstanceHolder类被初始化</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化一个类，包括执行这个类的静态初始化和初始化在这个类中声明的静态字段。根据java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被立即初始化：</p>
<blockquote>
<p>1、T是一个类，而且一个T类型的实例被创建；<br>2、T是一个类，且T中声明的一个静态方法被调用；<br>3、T中声明的一个静态字段被赋值；<br>4、T中声明的一个静态字段被使用，而且这个字段不是一个常量字段；<br>5、T是一个顶级类（top level class，见java语言规范的§7.6），而且一个断言语句嵌套在T内部被执行。</p>
</blockquote>
<p>在ClassLoaderDemo示例代码中，首次执行getInstance()的线程将导致InstanceHolder类被初始化（符合情况4）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果确实需要对实例字段使用线程安全的延迟初始化，请使用上面介绍的基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案</p>
<blockquote>
<font color="red">Effective Java 建议慎用Lazy Initialization</font>

</blockquote>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>1、单例模式<br>2、JVM类加载<br>3、synchronized关键字<br>4、volatile关键字</p>]]></content>
      
        <categories>
            
            <category> Java基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Effective Java </tag>
            
            <tag> 面向模式的软件体系架构卷三中Lazy Acquisition模式 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
